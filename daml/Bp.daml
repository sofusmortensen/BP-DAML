module Bp where

import DA.Next.Set as S
import qualified DA.List as L
import DA.Assert
import Daml.Script
import Util
import DA.Optional
import Effect qualified as E
import DA.List
import DA.Tuple

data Event 
  = Service with party : Party; text : Text
  | Transfer with tr: E.Transfer
  | Decision with party : Party; description : Text; choices : [(Text, Bool, [Event])]
  | End
  | Parallel [[Event]]
  | Race [[Event]]
  deriving (Eq, Show)

getParties : [Event] -> Set Party
getParties [] = empty
getParties (e::es) =
  union (getParties es)
    case e of
      Service p _ -> S.singleton p
      Decision p _ chs -> L.foldr union (S.singleton p) (map (getParties . thd3) chs)
      End -> empty
      Parallel ps -> L.foldr (flip union . getParties) empty ps
      Race ps -> L.foldr (flip union . getParties) empty ps
      Transfer _ -> empty

getControllers_par : [[Event]] -> Int -> Either [Party] Int
getControllers_par [] i = Right $ i
getControllers_par (es::ess) i =
  getControllers_ es i >>= getControllers_par ess

getControllers_ : [Event] -> Int -> Either [Party] Int
getControllers_ [] i = Left []
getControllers_ (e::es) i =
  case (e, i) of
    (Service _ _, _) -> getControllers_ es i
    (Decision p _ _, 0) -> Left [p]
    (Decision p _ _, i) -> Right $ i - 1
    (Parallel ps, i) -> getControllers_par ps i
    (Race ps, i) -> getControllers_par ps i
    (End, _) -> error "not implemented"
    (Transfer _, _) -> getControllers_ es i

getControllers : [Event] -> Int -> [Party]
getControllers es i = case getControllers_ es i of
  Right _ -> []
  Left ps -> ps

getControllers' : [Event] -> [(Text, Party)]
getControllers' [] = []
getControllers' (e::es) =
  case e of
    Service _ _ -> getControllers' es
    Decision p desc _ -> [(desc, p)]
    Parallel ps -> foldr1 (++) $ fmap getControllers' ps
    Race ps -> foldr1 (++) $ fmap getControllers' ps
    End -> error "not implemented"
    Transfer _ -> getControllers' es

selectProcess_par : [[Event]] -> Text -> Int -> (Int, Bool, [[Event]])
selectProcess_par [] _ i = (i, False, [])
selectProcess_par (es::ess) lbl i =
  let (j, sign, fs) = selectProcess es lbl i
  in fmap (\x -> fs::x) $ selectProcess_par ess lbl j

selectProcess : [Event] -> Text -> Int -> (Int, Bool, [Event])
selectProcess [] _ i = (i, False, [])
selectProcess (e::es) lbl i =
  case (e, i) of
    (Service _ _, _) -> selectProcess es lbl i
    (Decision actor _ cs, 0) ->
      case find ((lbl ==) . fst3) cs of
        None -> error "label not found"
        Some es' -> (i - 1, snd3 es', thd3 es' ++ es)
    (Decision actor txt cs, i) ->  (i - 1, False, (Decision actor txt cs)::es)
    (Parallel ps, i) ->
      let (i', sign, ps') = selectProcess_par ps lbl i
      in (i', sign, (Parallel ps')::es)
    (Race ps, i) ->
      let (i', sign, ps') = selectProcess_par ps lbl i
      in (i', sign, (Race ps')::es)
    (End, _) -> error "not implemented"
    (Transfer _, _) -> selectProcess es lbl i

generate : BusinessProcess -> [Event] -> Update [Event]
generate this [] = return []
generate this (e::es) =
  case e of
    End -> return []
    Service actor message -> do
      create E.Effect with issuer = this.parties; ..
      generate this es
    Transfer tr -> do
        if not $ member tr.payer this.parties then 
          return [Decision tr.payer "Authorize transfer" [("Sign", True, (Transfer tr)::es)]]
        else if not $ member tr.payee this.parties then 
          return [Decision tr.payee "Authorize transfer" [("Sign", True, (Transfer tr)::es)]]
        else
          do
            create tr
            generate this es
    Decision _ _ [] -> generate this es
    Decision actor txt cs -> return $ (Decision actor txt cs) :: es
    Parallel ps -> do
      ps' <- mapA (generate this) ps
      case L.filter (not . L.null) ps' of
        [] -> generate this es
        p::[] -> return $ p ++ es
        ps'' -> return $ (Parallel ps'') :: es
    Race ps -> do
      ps' <- mapA (generate this) ps
      if elem [] ps'
        then generate this es
        else case ps' of
        [] -> generate this es
        p::[] -> return $ p ++ es
        ps'' -> return $ (Race ps'') :: es

selectBody : BusinessProcess -> [Party] -> Text -> Int -> Update (Optional (ContractId BusinessProcess))
selectBody this actor txt i = do
  let parties' = S.union (S.fromList actor) this.parties
  pr <- generate this this.process
  let (_, sign, es) = selectProcess pr txt i --- sofus todo
  r <- generate (this with parties = parties') es
  case r of
    [] -> return None
    p -> do
      p' <- generate this p
      if sign then
        Some <$> create this with process = p'; parties = parties'
      else
        Some <$> create this with process = p'; observers = S.union (S.fromList actor) this.observers

template BusinessProcess
  with
    process : [Event]
    parties : Set Party
    observers : Set Party
  where
    signatory parties
    observer observers, snd <$> getControllers' process

    ensure not $ L.null process &&
           let p = getParties process in intersection p parties == p

    choice Select : Optional (ContractId BusinessProcess)
      with c : Int
           txt : Text
           actor : Party
      controller actor
        do
          [actor] === getControllers process c
          selectBody this [actor] txt c

    nonconsuming choice Status : [(Text, Party)]
      with actor : Party
      controller actor
      do
        return $ getControllers' process

head2 : [a] -> Optional a
head2 (_::[]) = None
head2 (h::_) = Some h
head2 [] = None

onlyOne : [a] -> Optional a
onlyOne (h::[]) = Some h
onlyOne _ = None

data BuilderM e a = BuilderM with state : a; transformation : e -> e
type Builder = BuilderM [Event] ()
type ChoiceBuilder = BuilderM [(Text, Bool, [Event])] ()
type ParallelBuilder = BuilderM [[Event]] ()

proc : Builder -> [Event]
proc (BuilderM _ xs) = xs []

in_parallel : ParallelBuilder -> Builder
in_parallel (BuilderM _ xs) = BuilderM () $ \l -> (Parallel (xs [])) :: l

race : ParallelBuilder -> Builder
race (BuilderM _ xs) = BuilderM () $ \l -> (Race (xs [])) :: l


line : Builder -> ParallelBuilder
line (BuilderM _ xs) = BuilderM () $ \x -> (xs []) :: x

service : Party -> Text -> Builder
service p t = BuilderM () $ (Service p t ::)

transfer : E.Service -> Party -> Party -> Text -> Decimal -> Builder
transfer svc payer payee ccy amount = BuilderM () $ (Transfer tr ::)
  where tr = E.Transfer svc payer payee ccy amount

select : Party -> Text -> ChoiceBuilder -> Builder
select p txt (BuilderM _ xs) = BuilderM () $ \l -> (Decision p txt $ xs []) :: l

nop = BuilderM () identity

ch : Text -> Builder -> ChoiceBuilder
ch txt (BuilderM _ xs) = BuilderM () $ \x -> (txt, True, xs []) :: x

chNosign : Text -> Builder -> ChoiceBuilder
chNosign txt (BuilderM _ xs) = BuilderM () $ \x -> (txt, False, xs []) :: x

cancel : Builder
cancel = BuilderM () (End ::)

instance Functor (BuilderM e) where
  fmap f (BuilderM a xs) = BuilderM (f a) xs

instance Applicative (BuilderM e) where
  pure a = BuilderM a identity
  (BuilderM f xs) <*> (BuilderM y ys) = BuilderM (f y) $ xs . ys

instance Action (BuilderM e) where
  BuilderM a xs >>= f = case f a of
    BuilderM b ys -> BuilderM b (xs . ys)

issueProcess : Party -> Builder -> Script (ContractId BusinessProcess)
issueProcess issuer (BuilderM _ bld) =
  let process = bld []
      ps = S.toList $ getParties process
  in do
    _create issuer BusinessProcess with parties = S.singleton issuer; process; observers = S.empty

mybp = script do
  acme <- allocateParty "acme"
  highStreetBank <- allocateParty "high street bank"
  rr <- allocateParty "road runner"
  wc <- allocateParty "wildey coyote"

  let pp = do
        service acme "ini A"
        select acme "proceed?" do
          ch "accept" $ service acme "ok B"
          ch "reject" do service acme "reject C"; cancel

        in_parallel do
          line do
            select acme "proceed?" do
              ch "accept" do
                service acme "ok D"
              ch "reject" do
                service highStreetBank "ok D"
                cancel

          line do
            select highStreetBank "proceed?" do
              ch "accept" do
                service highStreetBank "accept E"

          line do
            select rr "proceed?" do
              ch "accept" do
                service rr "meek meek"

        race do
          line do
            select acme "proceed?" do
              ch "accept" $ service acme "acme"
          line do
            select rr "proceed?" do
              ch "accept" $ service acme "rr"

        service wc "all done F"

  cid <- issueProcess acme pp

  cid <- _exercise' acme cid $ Select 0 "accept"

  cid <- _exercise' highStreetBank (fromSome cid) $ Select 1 "accept"

  cid <- _exercise' acme (fromSome cid) $ Select 0 "accept"

  cid <- _exercise' rr (fromSome cid) $ Select 0 "accept"

  cid <- _exercise' rr (fromSome cid) $ Select 1 "accept"

  assert True


mybp1 = script do
  acme <- allocateParty "acme"
  highStreetBank <- allocateParty "high street bank"

  let pp = proc do
        in_parallel do
          line do
            select acme "proceed?" do
              ch "accept" do
                service acme "ok D"

          line do
            select highStreetBank "proceed?" do
              ch "accept" do
                service highStreetBank "accept E"

        service acme "all done F"

  [acme] === getControllers pp 0
  [highStreetBank] === getControllers pp 1

  assert True

mybp2 = script do
  acme <- allocateParty "acme"
  highStreetBank <- allocateParty "high street bank"

  let pp = proc do
        select acme "proceed?" do
          ch "accept" do
            service acme "ok D"

        service acme "all done F"

  [acme] === getControllers pp 0
  [] === getControllers pp 1

mybp3 = script do
  acme <- allocateParty "acme"
  highStreetBank <- allocateParty "high street bank"
  roadrunner <- allocateParty "roadrunner"

  let pp = proc do
      in_parallel do
        line $ in_parallel do
          line do
            select acme "proceed?" do
              ch "accept" do
                service acme "ok D"

          line do
            select highStreetBank "proceed?" do
              ch "accept" do
                service highStreetBank "accept E"

        line do
          select roadrunner "proceed?" do
            ch "accept" do
              service highStreetBank "accept F"

      service acme "all done G"

  debug pp

  [acme] === getControllers pp 0
  [highStreetBank] === getControllers pp 1
  [roadrunner] === getControllers pp 2

ack party description = do
  service party ("Request: " <> description)
  select party "proceed?" do
    ch "ack" nop

ackNosign party description = do
  service party ("Request: " <> description)
  select party "proceed?" do
    chNosign "ack" nop

commercialFinancing = script do

  sales <- allocateParty "sales"
  treasury <- allocateParty "treasury"
  admin <- allocateParty "administration"
  credit <- allocateParty "credit"
  cust <- allocateParty "customer"
  bank <- allocateParty "bank"

  let svc = E.Service bank "cash"

  cid <- issueProcess sales do

    ack sales "Consolidate and Digitize Data"
    ack sales "Analyze Financial Data"
    select sales "Qualified Request?" do
      ch "Yes" do
        ack credit "Verify Credit Record with Credit Offices"
        ack treasury "Sign-off from Treasury"
        ackNosign admin "Prepare Detailed Analysis of Financial Data"
        ack sales "Prepare Detailed Analysis"
        select sales "Qualified Request?" do
          ch "Yes" do
            ack sales "Elaborate Commercial Financing Reporting"
            select cust "Accept?" do
              ch "No" do
                ack sales "Prepare and Transmit Refusal Letter"
                cancel
              ch "Yes" do
                transfer svc cust credit "EUR" 10000.0
                transfer svc admin cust "CHF" 12000.0
                ack sales "Complete purchase"
          ch "No" do
            ack sales "Prepare and Transmit Refusal Letter"
            cancel
      ch "No" do
        ack sales "Prepare and Transmit Refusal Letter"
        cancel

    service sales "Complete"

  Some cid <- _exercise' sales    cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' sales    cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' sales    cid $ Select 0 "Yes"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' credit   cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' treasury cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' admin    cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' sales    cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' sales    cid $ Select 0 "Yes"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' sales    cid $ Select 0 "ack"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' cust     cid $ Select 0 "Yes"
  _exercise' sales cid Status >>= debug
  Some cid <- _exercise' admin    cid $ Select 0 "Sign"
  _exercise' sales cid Status >>= debug
  None     <- _exercise' sales    cid $ Select 0 "ack"

  pure ()